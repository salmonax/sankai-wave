<html></html><head><title>Sankai Wave</title><style>html, body {
  height: 100%;
  margin: 0px;
  overflow: hidden;
}
body {
  background: black;
}
body *, #texture * {
  box-sizing: border-box;
}
.overlay {
  pointer-events: none;
  position: absolute;
  left: 0px;
  right: 0px;
  top: 0px;
  bottom: 0px;
  background: linear-gradient(20deg, #faf, #d28, #428 90%);
  opacity: 0.6;
}

.building {
  backface-visibility: hidden;
  position: relative;
  width: auto;
  height: auto;
  background: linear-gradient(90deg, #433, #766);
}
.story:first-of-type {
  margin-top: 50px;
}
.story {
  top: 0px;
  left: 0px;
  white-space: nowrap;
  width: auto;
  height: auto;
  margin-bottom: 100px;
  display: flex;
}
/* Argh, don't like having to specify this width/height */
/* They need to be calculated by hand */
.bake-story-window-4 {
  display: flex;
  padding: 50px 0px;
  height: 300px;
  width: 925px;
  background: linear-gradient(90deg, #433, #766);
}
.bake-story-window-pane-4 {
  display: flex;
  padding: 50px 0px;
  height: 350px;
  width: 925px;
  background: linear-gradient(90deg, #433, #766);
}

.window {
  background: linear-gradient(45deg, #645, #98a 50%, #645, #98a);
  box-shadow: inset 0px 0px 10px 10px #879;
  border: 4px solid #311;
  border-bottom: 4px solid #a99;
  border-left: 4px solid #a99;
  margin-left: 25px;
  height: 200px;
  width: 200px;
}
.window-pane {
  display: flex;
  flex-direction: column;
  margin-left: 25px;
  height: 250px;
  width: 200px;
}
.window-pane .pane {
  width: 100%;
  height: 95%;
  //- background: linear-gradient(45deg, #645, #98a 50%, #645, #98a);
  background: linear-gradient(45deg, #645, #a89 50%, #645, #a89);
  border: 4px solid #311;
  border-bottom: 4px solid #a99;
  border-left: 4px solid #a99;
  box-shadow: inset 0px 0px 10px 5px #a89;
  flex-grow: 2;
}
.window-pane .pane-row {
  display: flex;
  align-items: center;
  flex-grow: 2;
}
.window-pane .pane-row:first-of-type {
  flex-grow: 1;
}

.window:last-of-type, .window-pane:last-of-type {
  margin-right: 25px;
}
.scanlines {
  position: absolute;
  pointer-events: none;
  left: 0px;
  right: 0px;
  top: 0px;
  bottom: 0px;
  opacity: 0.1;
  background: linear-gradient(#000, #faf);
  background-size: 100% 4px;
  z-index: 500;
  animation: scan 500ms linear infinite;
  transform: translate3d(0,0,0);
  backface-visibility: hidden;
}

@keyframes left {
  0% {
    opacity: 0;
    transform: rotate3d(-0.4, 1, -0.4, 70deg) scale3d(0.8, 0.8, 1) translate3d(6000px, 0, 0);
  }
  25% {
    opacity: 1;
  }
  100% {
    transform: rotate3d(-0.4, 1, -0.4, 70deg) scale3d(0.8, 0.8, 1) translate3d(-3000px, 0, 0);
  }
}
@keyframes right {
  0% {
    opacity: 0;
    transform: rotate3d(0.3, 1, -0.2, 250deg) scale3d(0.7, 0.7, 1) translate3d(-3000px,0,-500px);
  }
  25% {
    opacity: 1;
  }
  100% {
    transform: rotate3d(0.3, 1, -0.2, 250deg) scale3d(0.7, 0.7, 1) translate3d(3000px,0,-500px);
  }
}

#viewport {
  height: 100%;
}
.viewport {
  perspective: 600px;
  position: relative;
  width: 100%;
  height: 100%;
}
.camera, .camera * {
  transform-style: preserve-3d;
}
/*
  Currently, .assembly and .prefab mean nearly the same thing, but .assembly
  refers to the root element, whereas .prefab refers to the root of any
  element intended to be positioned in 3D, with children NOT in flow. The main styling difference is that
  .prefab children are forced have their transform-origin properties normalized.
*/
.camera, .assembly, .assembly > *, .prefab, .prefab > * {
  position: absolute;
  left: 50%;
  top: 50%;
}
.prefab * {
  /* Force default transform-origin on elements inside a prefab */
  transform-origin: 50% 50%;
  backface-visibility: hidden;
}
.camera {
  transform: rotateX(0deg) rotateY(270deg) rotateZ(0deg) translate3d(0px, 0px, 0px) skewX(0deg) skewY(0deg);
  transform-origin: 50% 50% 600px;
}
.camera * {
  transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) translate3d(0px, 0px, 0px) skewX(0deg) skewY(0deg);
}
.floor, .street {
  box-shadow: inset 0px 0px 100px 5px #f0f, 0px 0px 100px 20px #f0f;
  border: 5px solid #faf;
  width: 1000px;
  height: 800px;
  //- border: 10px solid #444;
  //- transform-origin: 50% 100%;
  background: linear-gradient(#333, #889);
  background: black;
  //- transform: rotateX(90deg) rotateY(0deg) rotateZ(0deg) translate3d(0px, 0px, 0px) skewX(0deg) skewY(0deg);
}
.floor.first {
  width: 10000px;
}
/* Surface is for elements whose children are in-flow; 0.99 opacity fixes *some* artifacting */
/* Will probably deprecate this, as it doesn't work terribly well */
/* Note: if a prefab seems to need that 0.999 opacity tweak to avoid clipping, it's probably a surface! */
.surface * {
  //- opacity: 0.999;
  backface-visibility: hidden;
  transform: translateZ(1px) !important;
}
.red-karaoke {
  --side-color: #701;
  --depth: 50;
  width: 140px;
  height: 910px;
  transform-origin: 0% 100%;
  box-shadow: inset 0px 0px 30px 10px #c00, 0px 0px 20px 10px red;
  background: red;
  border-radius: 10px;
  writing-mode: vertical-rl;
  text-orientation: upright;
  padding-top: 60px;
  color: white;
  font-weight: bold;
  font-size: 100px;
  line-height: 150px;
}
.flickering {
  animation: signage-flicker 200ms infinite;
}
.row {
  display: flex;
  justify-content: center;
  align-items: center;
  //- line-height: 0px;
  height: 100%;
}
.col {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
}
@keyframes signage-flicker {
  //- 0% {
  //-   color: #fff;
  //- }
  //- 100% {
  //-   color: #ddd;
  //- }
}

@keyframes signage-flicker2 {
  //- 0% {
  //-   filter: brightness(0.93);
  //- }
  //- 100% {
  //-   filter: brightness(1);
  //- }
}
.flicker2 {
  animation: signage-flicker2 400ms infinite;
}
.star-container {
  width: 1000px;
  height: 1000px;
  background: red;
  background-size: cover;
}

.book-off {
  --side-color: #024;
  --depth: 100;
  position: absolute;
  border: 15px solid #005;
  font-family: monospace;
  background: black;
  display: flex;
  flex-direction: column;
  width: 400px;
  height: 480px;
  transform-origin: 0% 100%;
  box-shadow: 0px 0px 20px 0px #00a8;
  background: blue;
  //- border-radius: 5px;
  overflow: hidden;
  color: white;
  font-weight: bold;
  font-size: 80px;
  line-height: 150px;
}
/* TODO: make the following styles intelligible */
.book-off * {
}

.book-off > .row:nth-of-type(1) {
  background: yellow;
  color: #00a;
  text-align: center;
  height: 25%;
}
.book-off > .row:nth-of-type(2) {
  height: 230px;
}
.book-off > .row:nth-of-type(2) > .col:nth-of-type(1) {
  -webkit-text-stroke: 2px black;
  font-size: 160px;
  border: 5px solid #00a;
  background: red;
}
.book-off > .row:nth-of-type(2) > .col:nth-of-type(2) {
  -webkit-text-stroke: 2px black;
  line-height: 0px;
  background: #00a;
}
.book-off > .row:nth-of-type(3) {
  color: black;
  background: white;
  height: 110px;
}
.book-off > .row:nth-of-type(3) > .col:nth-of-type(1) {
  color: red;
  font-size: 120px;
  width: 50%;
  background: white;
}
.book-off > .row:nth-of-type(3) > .col:nth-of-type(2) {
  color: black;
  background: white;
  //- line-height: 0px;
  font-size: 40px;
}
.book-off .game {
  font-size: 60px;
  margin-top: -50px;
}
.book-off .book {
  padding-top: 20px;
}
#templates {
  position: absolute;
  display: none;
}
.building-container {
  //- display: none;
}
.moon-container .texture {
  position: absolute;
  background: white;
  border-radius: 1000px;
  opacity: 1;
  //- filter: brightness(2.1);
  width: 500px;
  height: 500px;
}
.texture:hover {
  width: 900px;
  height: 900px;

}
.moon-shading {
  position: absolute;
  width: 500px;
  height: 500px;
  border-radius: 1000px;
  opacity: 1;
  background: radial-gradient(#fff3, #4446 50%, #fff5);
  box-shadow: inset 0px 0px 50px 10px #acc0, 0px 0px 100px 50px #acc8;
  background-size: 108% 108%;
  will-change: box-shadow;
  transition: box-shadow 300ms;
  /* Want a more general solution, but these transforms help with z-clipping */
  transform: translateZ(2px) !important;
}

.moon-shading:hover {
  transition: box-shadow 600ms;
  //- background: radial-gradient(#fff6, #4446 50%, #f9f9);
  box-shadow: inset 0px 0px 50px 10px #accf, 0px 0px 100px 50px #acff;
}
.book-off .circle {
  width: 30px;
  height: 30px;
  background: #00a;
  border-radius: 50px;
  margin: 65px 5px;
}
.hidden {
  opacity: 0;
}
.megaman {
  width: 300px;
  height: 300px;
}
.megaman img {
  width: 100%;
  height: 100%;
}
.book-off .inner-bevel, .yosh .inner-bevel {
  position: absolute;
  width: 100%;
  height: 100%;
  box-shadow: inset 0px 0px 10px #403;
  //- background: radial-gradient(#fff4, #f509);
  z-index: 100;
  pointer-events: none;
}
.matsuya {
  --side-color: #444;
  --depth: 50;
  position: absolute;
  border: 8px solid #222;
  width: 148px;
  height: 438px;
  transform-origin: 0% 100%;
  background: #fb0;
  font-weight: 900;
  word-break: break-all;
}
.matsuya .inset {
  position: absolute;
  box-shadow: inset 0px 0px 10px 0px #301;
  width: 100%;
  height: 100%;
}
.matsuya .middle > .circle {
  position: absolute;;
  background: #f00;
  width: 95px;
  height: 95px;
  border-radius: 80px;
  left: 18px;
  top: 70px;
}
.matsuya .circle > .circle:nth-of-type(1) {
  position: absolute;
  left: 18px;
  top: 22px;
  width: 32px;
  height: 32px;
  background: #fc0;
  border-radius: 20px;
}
.matsuya .circle > .circle:nth-of-type(2) {
  position: absolute;
  left: 44px;
  top: 40px;
  width: 35px;
  height: 35px;
  background: blue;
  border-radius: 20px;
}
.matsuya .bottom, .matsuya .top {
  position: absolute;
  height: 36px;
  width: 100%;
  background: blue;
}
.matsuya .top {
  top: 0px;
}
.matsuya .bottom {
  bottom: 0px;
}
.matsuya .outer, .matsuya .inner {
  text-align: center;
  position: absolute;
  line-height: 110px;
  font-size: 75px;
  line-height: 80px;
  top: 195px;
}
.matsuya .inner {
  -webkit-text-stroke: 5px blue;
  color: blue;
}
.matsuya .outer {
  -webkit-text-stroke: 10px white;
  color: white;
}


.manga-kissa {
  --side-color: #701;
  --depth: 50;
  position: absolute;
  font-family: sans-serif;
  width: 134px;
  height: 492px;
  border: 6px solid red;
  word-break: break-all;
  transform-origin: 0% 100%;
  box-shadow: inset 0px 0px 0px 5px red, 0px 0px 10px 4px red;
  background: #ff8;
  border-radius: 5px;
  padding-top: 18px;
  color: #0ff;
  font-weight: 900;
  font-size: 120px;
  line-height: 90px;
  -webkit-text-stroke: 5px #09f;
}
.manga-kissa-inner {
  padding-left: 10px;
  position: absolute;
  top: 0px;
  left: 0px;
  font-family: sans-serif;
  word-break: break-all;
  padding-top: 18px;
  color: yellow;
  font-weight: 900;
  font-size: 100px;
  line-height: 90px;
  -webkit-text-stroke: 3px #334;
  text-shadow: 0px 0px 20px #0ff;
}
.yosh {
  --side-color: #444;
  --depth: 50;
  position: absolute;
  border: 8px solid #222;
  background: black;
  display: flex;
  flex-direction: column;
  width: 150px;
  height: 900px;
  transform-origin: 0% 100%;
  box-shadow: 0px 0px 20px 0px #00a8;
  background: #f90;
  //- border-radius: 5px;
  overflow: hidden;
  color: white;
  font-weight: bold;
  font-size: 80px;
}
.yosh .white-stripe {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  //- padding-left: 5px;
  line-height: 20px;
  color: black;
  font-family: sans-serif;
  font-size: 300px;
  position: absolute;
  height: 100%;
  background: white;
  width: 30px;
  right: 15px;
}
.yosh .inner-bevel {
  box-shadow: inset 0px 0px 10px 5px #a40;
}
.yosh .block {
  width: 10px;
  margin: 6px 2px;
  height: 10px;
  background: black;
}
.yosh .side-text {
  display: flex;
  font-family: sans-serif;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 90px;
  color: black;
  //- background: yellow;
  height: 100%;
  margin-bottom: 100px;
}
.yosh .side-text .gyuu {
  font-size: 40px;
  width: 40px;
  //- background: red;
  height: 100px;
  margin-top: 75px;
}
.yosh .side-text .name {
  //- background: blue;
  line-height: 90px;
  padding-left: 10px;
  font-size: 70px;
  font-weight: 900;
}
.yosh .side-text .jikan {
  //- background: green;
  white-space: nowrap;
  width: 120px;
  font-size: 25px;
  transform-origin: 50% 100% !important;
  transform: scale(0.75, 1.25);
  height: 70px;
  margin-left: -6px;
}
.yosh  text .jikan .col:first-of-type {
  align-items: flex-end;
  font-size: 40px;
}
.ball {
  border-radius: 300px;
  width: 100px;
  height: 100px;
  transform-origin: 50% 50%;
  background: radial-gradient(#fff, #09f 25%, #000 60%, #44a) no-repeat;
  background-size: 150% 150%;
  background-position: 10% 100%;
  backface-visibility: hidden;
}
.ball-light {
  border-radius: 50px;
  width: 50px;
  height: 50px;
  transform-origin: 50% 50%;
  background: radial-gradient(#fff, #fff);
  box-shadow: 0px 0px 30px 10px white;
  background-position: 10% 100%;
  backface-visibility: hidden;
}
.lantern-red, .lantern-white {
  border-radius: 35px;
  width: 80px;
  height: 120px;
  transform-origin: 50% 50%;

  background-size: 100% 6px;
  background-position: 10% 100%;
  backface-visibility: hidden;
}
.lantern-red {
  background-image: linear-gradient(red, #ff0 20%, #faa 80%, red);
  box-shadow: 0px 0px 20px 4px #f35, inset 0px 0px 20px 20px #f00a;
}
.lantern-white {
  background-image: linear-gradient(#f30, #ff0 20%, #fda 80%, #f30);
  box-shadow: 0px 0px 20px 4px #f95, inset 0px 0px 20px 20px #ffab, inset 0px 0px 10px 4px #f00;
}

#diagnostics {
  padding: 10px;
  white-space: pre;
  font-family: monospace;
  font-size: 10px;
  position: absolute;
  left: 10px;
  top: 10px;
  min-width: 200px;
  min-height: 100px;
  background: #334;
  color: white;
  border-radius: 2px;
  border: 1px solid #fffa;
  display: none;
}
#template-editor {
  position: absolute;
  top: 0px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  margin-left: auto;
  width: 100%;
  height: 100%;
  overflow: auto;
  background: linear-gradient(20deg, #939, #a16, #317 90%);

  z-index: 100;
  //- transform: scale(0.5);
  transform-origin: 0% 0%;
  //- display: none;
  //- transition: opacity 200ms;
  //- opacity: 1;
  //- pointer-events: unset;
}
#template-editor.hidden {
  //- pointer-events: none;
  display: none;
  //- opacity: 0;
}
#template-editor .flex-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 870px;
  margin-bottom: 50px;
}
.editor-icon {
  //- display: flex;
  //- justify-content: center;
  //- align-items: center;
  width: 300px;
  height: 300px;
  margin: 10px;
  background: linear-gradient(120deg, #546, #757, #546);
  border-radius: 2px;
  border: 5px outset #555;
  box-shadow: 16px 16px 15px 0px #334a;
}
.flex-container .editor-icon:hover {
  outline: 2px solid orange;
}
.editor-icon > * {
  position: absolute;
  //- transform: scale(0.20) !important;
  transform-origin: 0% 0%;
  //- background: red;
}
.flex-container > .editor-icon > * {
  //- pointer-events: none;
}
.moon-container {
  width: 500px;
  height: 500px;
}
.big-first * {
}
.big-first {
  position: fixed;
  border-bottom: 5px solid #646;
  box-shadow: 0px 0px 20px black;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  height: 840px;
  top: 0px;
  width: 100%;
  background: linear-gradient(20deg, #939, #a16, #317 90%);
  z-index: 10;
}

#template-editor::-webkit-scrollbar {
  display: none;
}

.densha {
  //- border: 5px solid black;
  height: 300px;
  width: 600px;
  background: #444;
  display: flex;
}
.densha * {
  display: flex;
}
.densha .window-section, .densha .door-section {
  flex-direction: column;
  flex-grow: 2;
}
.densha .door-section {
  flex-grow: 1;
}
.densha .top, .densha .window-section .middle {
  box-shadow: inset 0px -3px 0px #aaa, inset 0px 3px 0px #333;
  border-bottom: 3px solid #777;
}
.densha .top {
  //- flex-grow: 1;
  height: 50px;
  background: linear-gradient(90deg, #555, #777, #555);
}
.densha .middle {
  align-items: center;
  justify-content: center;
  flex-grow: 3.25;
  background: linear-gradient(45deg, #444, #777, #444);
}
.densha .door-section .middle {
  flex-grow: 5;
  background: linear-gradient(45deg, #555 30%, #999 70%, #555);
}
.densha .door-section .top {
  justify-content: center;
  background: linear-gradient(90deg, #444 15%, #164 10%, #275 85%, #444 85%);
}
.densha .door-frame {
  width: 90%;
  height: 95%;
  //- background: linear-gradient(45deg, #450 30%, green);
  background: linear-gradient(-30deg, #353 20%, #386, #343);
  border-radius: 20px;
  border: 4px inset #999;
  box-shadow: inset 0px 6px 10px #313;
}
.window-frame {
  //- background: red;
  display: flex;
  justify-content: center;
  align-items: flex-end;
  height: 60%;
  width: 50%;
}
.separator {
  height: 100%;
  align-self: center;
  width: 4px;
  background: black;
}
.densha .door-frame .train-window {
  border-radius: 4px;
}
.densha .door-frame .train-window {
  width: 50%;
}
.densha .train-window {
  background: linear-gradient(-45deg, #545, #a98 30%, #466, #99a);
  box-shadow: inset 0px 0px 10px #999;
  border: 4px inset #999;
  height: 80%;
  width: 60%;
  border-radius: 20px;

}
.densha .bottom {
  box-shadow: inset 0px 2px 0px #333;
  background: linear-gradient(#888 15%, #666, #555);
  flex-grow: 1.5;
}
.famima-flat, .lawson-flat {
  color: blue;
  font-family: sans-serif;
  font-weight: 900;
  font-size: 50px;
  display: flex;
  flex-direction: column;
  width: 700px;
  height: 125px;
  background: white;
}
.famima-flat > *, .lawson-flat > * {
  width: 100%;
  display: flex;
}
.famima-flat .top {
  height: 35px;
  background: linear-gradient(#0a0, #0a0, #090);
  box-shadow: 0px 0px 6px #558;
}
.famima-flat .bottom {
  height: 12px;
  background: linear-gradient(#44f, blue);
  box-shadow: 0px 0px 6px #585;
}
.famima-flat .middle, .lawson-flat .middle {
  align-items: center;
  justify-content: center;
  flex-grow: 2;
}
.famima-flat .square {
  width: 40px;
  height: 40px;
  background: blue;
  margin: 5px;
}
.famima-flat .circle {
  width: 40px;
  height: 40px;
  background: blue;
  margin: 5px;
  border-radius: 40px;
}
.brand-square .square {
  height: 17px;
  margin: 5px;
}
.brand-square {
  margin-right: 15px;
}
.brand-square .square:first-of-type {
  background: green;
}
.lawson-flat .top, .lawson-flat .bottom {
  background: white;
  height: 20px;
}
.lawson-flat .bottom {
  padding: 4px 0px;
}
.lawson-flat .middle {
  background: linear-gradient(0deg, #44e, #55f 20%, #44e, #57f);
  flex-grow: 2;
}
.lawson-flat .stripe {
  background: red;
  border-top: 4px solid #55f;
  border-bottom: 4px solid #55f;
  height: 100%;
  width: 100%;
}
.lawson-flat .circle {
  width: 30px;
  height: 30px;
  margin: 10px;
  border-radius: 100px;
  background: white;
}
.lawson-flat .vert {
  position: absolute;
  width: 20px;
  height: 100%;
  background: linear-gradient(90deg, #fff 10%, #669, #fff 90%);
}
.lawson-flat .vert.left {
  left: 25%;
}
.lawson-flat .vert.right {
  right: 25%;
}
.conbini {
  width: 700px;
  height: 500px;
  display: flex;
}
.conbini > * {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  background: linear-gradient(-30deg, #888 20%, #fff, #888, #fff);
}
.conbini .top, .conbini .bottom {
  height: 71px;
}
.conbini .door-section {
  width: 150px;
}
.conbini .middle {
  flex-grow: 1;
}
.conbini .window-section, .conbini .door-section {
  padding: 10px 5px;
  display: flex;
}
.conbini .door-section {
  padding-bottom: 0px;
}
.conbini .door-section > *, .conbini .window-section > * {
  display: flex;
  justify-content: center;
  align-items: center;
}
.conbini .door-section > *, .conbini .window-section > * {
  width: 100%;
}

.conbini .window-pane, .conbini .wall, .conbini .door {
  width: 95%;
  height: 95%;
  border: 3px inset grey;
}
.conbini .window-pane, .conbini .door {
  background: linear-gradient(40deg, #fdf, #faf, #ffe, #adf, #fff);
  box-shadow: inset 0px 0px 10px #a46;
}
.conbini .wall {
  background: #dda;
  box-shadow: inset 0px 5px 15px #88a;
}
.conbini .door-container {
  padding-top: 10px;
  display: flex;
  flex-direction: row;
  height: 100%;
  width: 100%;
}
.conbini .door {
  box-shadow: inset 0px 5px 10px #aaf;
  height: 100%;
}
.range-container {
  position: absolute;
  bottom: 0px;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
}
#anim {
  display: flex;
  align-self: center;
  justify-self: center;
  width: 90%;

  z-index: 4;
  bottom: 0px;
}</style></head><body><div class="surface" id="templates"><div class="bake-story-window-4"><div class="window"></div><div class="window"></div><div class="window"></div><div class="window"></div></div><div class="bake-story-window-pane-4"><div class="window-pane"><div class="pane-row"><div class="pane"></div><div class="pane"></div></div><div class="pane-row"><div class="pane"></div><div class="pane"></div></div></div><div class="window-pane"><div class="pane-row"><div class="pane"></div><div class="pane"></div></div><div class="pane-row"><div class="pane"></div><div class="pane"></div></div></div><div class="window-pane"><div class="pane-row"><div class="pane"></div><div class="pane"></div></div><div class="pane-row"><div class="pane"></div><div class="pane"></div></div></div><div class="window-pane"><div class="pane-row"><div class="pane"></div><div class="pane"></div></div><div class="pane-row"><div class="pane"></div><div class="pane"></div></div></div></div><div class="street"></div><div class="lantern-white sprite"></div><div class="lantern-red sprite"></div><div class="matsuya"><div class="top"></div><div class="middle"><div class="circle"><div class="circle yellow"></div><div class="circle blue"></div></div><div class="outer">松屋</div><div class="inner">松屋</div></div><div class="bottom"></div><div class="inset"></div></div><div class="conbini"><div class="window-section"><div class="top"><div class="window-pane"></div></div><div class="middle"><div class="window-pane"></div></div><div class="bottom"><div class="wall"></div></div></div><div class="door-section"><div class="top"><div class="window-pane"></div></div><div class="middle"><div class="door-container"><div class="door"></div><div class="door"></div></div></div></div><div class="window-section"><div class="top"><div class="window-pane"></div></div><div class="middle"><div class="window-pane"></div></div><div class="bottom"><div class="wall"></div></div></div></div><div class="lawson-flat"><div class="top"></div><div class="middle"><div class="circle"></div><div class="circle"></div><div class="circle"></div></div><div class="bottom"><div class="stripe"></div></div><div class="vert left"></div><div class="vert right"></div></div><div class="famima-flat"><div class="top"></div><div class="middle"><div class="brand-square"><div class="square"></div><div class="square"></div></div><div class="circle"></div><div class="circle"></div><div class="circle"></div></div><div class="bottom"></div></div><div class="window-pane"><div class="pane-row"><div class="pane"></div><div class="pane"></div></div><div class="pane-row"><div class="pane"></div><div class="pane"></div></div></div><div class="densha"><div class="window-section"><div class="top"></div><div class="middle"><div class="train-window"></div></div><div class="bottom"><div class="label"></div></div></div><div class="door-section"><div class="top"></div><div class="middle"><div class="door-frame"><div class="window-frame"><div class="train-window"></div></div><div class="separator"></div><div class="window-frame"><div class="train-window"></div></div></div></div></div></div><div class="ball sprite"></div><div class="ball-light sprite"></div><div class="window"></div><div class="megaman"><img src="megaman.gif"/></div><div class="moon-container surface"><div class="texture"></div><div class="moon-shading"></div></div><div class="book-off signage flicker2 surface"><div class="row"><div class="circle"></div><div class="circle"></div><div class="circle"></div><div class="circle hidden"></div><div class="circle"></div><div class="circle"></div><div class="circle"></div></div><div class="row"><div class="col book">本</div><div class="col"><div class="row">DVD</div><div class="row game">ゲーム</div></div></div><div class="row"><div class="col">←</div><div class="col"><div class="row sugu">この先すぐ</div></div></div><div class="inner-bevel"></div></div><div class="red-karaoke signage flickering surface">カラオケ○歌広場</div><div class="manga-kissa signage flicker2 surface">まんが喫茶<div class="manga-kissa-inner">まんが喫茶</div></div><div class="yosh signage flicker2 surface"><div class="white-stripe"><div class="block"></div><div class="block"></div><div class="block"></div><div class="block hidden"></div><div class="block"></div><div class="block"></div><div class="block"></div><div class="block hidden"></div><div class="block"></div><div class="block"></div><div class="block"></div></div><div class="side-text"><div class="row gyuu">牛肉</div><div class="row name">吉野家</div><div class="row jikan"><div class="col">24</div><div class="col"><div class="row">時間</div><div class="row">営業</div></div></div></div><div class="inner-bevel"></div></div></div><div id="viewport"><div class="viewport"><div class="camera"><div class="assembly"></div></div></div></div><div class="overlay"></div><div class="scanlines"></div><div class="range-container"><input id="anim" type="range" min="0" max="500" value="0"/></div><div id="diagnostics"></div><div class="hidden" id="template-editor"><div class="big-first"></div><div class="flex-container"></div></div><script>// Basic manipulation functions
//const $ = document.querySelector.bind(document);
const pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x);
const $ = (selector, withTemplates = false) => {
  // This function has gotten brittle and dumb. Fix.
  withTemplates = withTemplates || /(#templates|(\s+|^)style)/.test(selector);
  if (!withTemplates) selector = 'div:not(#templates) ' + selector + ', body > ' + selector;
  return document.querySelector(selector);
};
const $$ = (selector, withTemplates = false) => {
  // This function has gotten brittle and dumb. Fix.
  withTemplates = withTemplates || /(#templates|(\s+|^)style)/.test(selector);
  if (!withTemplates) selector = 'div:not(#templates) ' + selector + ', body > ' + selector;
  //- console.error(selector);
  // Make it an array; controversial.
  return [].slice.apply(document.querySelectorAll(selector));
};
//- const $$ = document.querySelectorAll.bind(document);
const p = (...input) => { console.log(...input); return input[0]; }
const div = (classNames, style, posRot) => {
  const _div = document.createElement('div');
  classNames.split('.').filter(n => !!n).forEach(className => {
    _div.classList.add(className);
  });

  Object.assign(_div.style, style);
  move(_div, ...(posRot || [null, null]), true);
  return _div;
};
const rad = deg => deg * Math.PI / 180;
const { sin, cos, max, min } = Math;

const $camera = $('.camera');
const $assembly = $('.assembly');

const defaults = {
  cameraPosRot: [[0, 0, 0], [0, 0, 0]],
  assemblyPosRot: [[0, 0,0], [0, 0, 0]],
}
let config = {
  runtime: {
    bakedHashMap: {}, // this isn't really config though, is it?
    editorMode: false,
    selectedTemplate: 0,
  },
  persistView: true,
  saveOnBlur: true, // not using; always does it
  mouseLook: false,
  // Just paste the desired state (logged to console on save) to bake it
  //- bakedState: '{"cameraPosRot":[[0,0,0],[9,-91,0]],"assemblyPosRot":[[-1626.3416841417193,90,1030.102044273865],[0,0,0]]}',
  bakedState: '{"cameraPosRot":[[0,0,0],[4,315,0]],"assemblyPosRot":[[-15557,-260,-5789],[0,0,0]]}',

};

const storage = {
  __key: '__kludgeFactory__',
  __cache: null,
  load(_engine = engine) {
    //- if (!engine.isDevHost()) {
    //-   console.warn('STORAGE: skipped dev-state load; non-dev host detected.');
    //-   return;
    //- }
    if (!this.__cache) {
      this.__cache = JSON.parse(window.localStorage.getItem(this.__key));
    }
    return this.__cache;
  },
  save(obj, merge, _engine = engine) {
    //- if (!engine.isDevHost()) {
    //-   console.warn('STORAGE: skipped dev-state save; non-dev host detected.');
    //-   return;
    //- }
    if (!obj) throw new Error('Attempted to save to storage without an argument.');
    if (merge) obj = Object.assign(this.load() || {}, obj);
    window.localStorage.setItem(this.__key, JSON.stringify(obj));
    this.__cache = obj;
  },
};

const db = {
    _version: 1,
    _dbName: '__kludgeFactory__',
    _storeName: 'bakedImageMap',
    _db() {
        if (!this.__dbPromise) {
            this.__dbPromise = new Promise((r, onerror) => Object.assign(
                window.indexedDB.open(this._dbName, this._version), {
                    onupgradeneeded: e => e.target.result.createObjectStore(this._storeName),
                    onsuccess: e => r(e.target.result),
                    onerror,
                }),
            );
        }
        return this.__dbPromise;
    },
    async _tx(verb, ...args) {
        return new Promise(async (onsuccess, onerror) =>
            Object.assign(
                (await this._db())
                    .transaction([this._storeName], 'readwrite')
                    .objectStore(this._storeName)[verb](...args),
                { onsuccess, onerror },
            )
        )
    },
    putBlobFromUrl(key, url) {
        return fetch(url)
            .then(r => r.blob())
            .then(blob => this._tx('put', blob, key));
    },
    getBlobAsUrl(key) {
        return this._tx('get', key)
            .then(e => e.target.result && window.URL.createObjectURL(e.target.result));
    },
    __dbPromise: null,
}
const animation = {

}

const diagnostics = {
  _el: $('#diagnostics'),
  _lastE: null,
  update(e) {
    if (e) this._lastE = e;
    e = e || this._lastE || '';
    const [cx, cy, cz] = $camera._pos;
    const [crx, cry, crz] = $camera._rot;

    const [ax, ay, az] = $assembly._pos;
    const [arx, ary, arz] = $assembly._rot;
    const s = (e && e.target._pos) || '';
    if (s) {
      var [ex, ey, ez] = e.target._pos || Array(3).fill('');
      var [erx, ery, erz] = e.target._rot || Array(3).fill('');
    }
    if (e) {
      var selector = '';
      const sClasses = [].slice.apply(e.target.classList).join('.');
      const sId = e.target.id;
      if (sClasses) selector += '.' + sClasses;
      if (sId) selector += '#' + sId;
    }

    const [bx, by, bz] = $('.ball').parentNode._pos;
    console.log(bx, by, bz);

    const { perspective: pz } = engine;

    const adj = bx-ax
    let adjZ
    const opp = adjZ = bz-az+pz;
    const oppY = ay-by;

    const distanceXZ = Math.sqrt(adj**2 + opp**2);

    const deg = rad => rad*180/Math.PI;
    const lookAtY = -(deg(Math.atan2(opp,adj))-90);
    const lookAtX = deg(Math.atan2(oppY,distanceXZ));

    const $ball = $('.ball');
    const $ballGimbal = $ball.parentNode;
    //- move($ballGimbal, null, [0, 0, 0], true);
    //- move($ball, null, [bx, lookAtY, bz], true);

    setMatrix(
      $ballGimbal,
      calculateLookAtMatrix(
        [bx, by, bz],
        [ax, ay, az-pz],
        [0, 1, 0],
      ),
    );




    this._el.innerText = trimdent(`
      ${bx} ${bz}
      ${ax} ${az}
      ${adjZ} ${oppY}

      ${lookAtX}

      ${distanceXZ}

      assembly:
        x: ${ax}
        y: ${ay}
        z: ${az}

        rx: ${arx}
        ry: ${ary}
        rz: ${arz}

      camera:
        x: ${cx}
        y: ${cy}
        z: ${cz}

        rx: ${crx}
        ry: ${cry}
        rz: ${crz}

      ${e && selector}
        ${s && 'x: '  + ex}
        ${s && 'y: '  + ey}
        ${s && 'z: '  + ez}

        ${s && 'rx: '  + erx}
        ${s && 'ry: '  + ery}
        ${s && 'rz: '  + erz}
    `);
  }
}

const engine = {
  // hmm, should perspective go here?
  viewport: $('.viewport'),
  camera: $('.camera'),
  isDevHost: () => window.location.host.includes('localhost'),
  get perspective() { return parseInt(window.getComputedStyle(this.viewport).perspective) },
  set perspective(setting) {
    this.viewport.style.perspective = setting + 'px';
    this.camera.style.transformOrigin = `50% 50% ${setting}px`;
  },
  _frameRate: 5,
  __lastUpdate: Date.now(),
  // TODO: in order for this to actually work correctly, the update
  // cycle needs to compensate for missed cycles; otherwise it just
  // slows down movement. At the very least, it should keep a tick count
  // and send it into the keyboard, which it can then use to press the held
  // keys a given number of times.
  shouldUpdate: () => true,
    //Date.now() - engine.__lastUpdate >= 1000/engine._frameRate,
  update(keyboard) {
    if (this.shouldUpdate()) {
      keyboard.run();
      //- diagnostics.update();
      this.__lastUpdate = Date.now();
      //- console.log($assembly._pos, $('.ball')._pos);

      // Do the ball stuff
      this._updateSprites();

    }
    requestAnimationFrame(() => this.update(keyboard));
  },
  _$$sprites: null,
  _updateSprites() {
    // WARNING: no special care is being kept to make sure that
    // this cache stays updated!

    // TODO: when exiting gallery, $$('.sprite') doesn't correctly skip #templates for some reason,
    // so specifying #viewport explicitly. Fix later.
    if (!this._$$sprites) this._$$sprites = $$('#viewport .sprite');
    if (!this._$$sprites) return;

    const [ax, ay, az] = $assembly._pos;
    const { perspective: pz } = engine;
    const deg = rad => rad*180/Math.PI;

    this._$$sprites.forEach($sprite => {
      const $spriteGimbal = $sprite.parentNode;
      const [sx, sy, sz] = $spriteGimbal.parentNode._pos; // position is in the top-level container

      const adj = sx-ax;
      const opp = sz-az+pz;
      const oppY = ay-sy;
      const distanceXZ = Math.sqrt(adj**2 + opp**2);

      const lookAtY = -(deg(Math.atan2(opp,adj))-90);
      const lookAtX = deg(Math.atan2(oppY,distanceXZ));

      setMatrix(
        $spriteGimbal,
        calculateLookAtMatrix(
          [-sx, -sy, -sz],
          [ax, ay, az-pz],
          [0, 1, 0],
        ),
      );

    });
  },
}

const action = {
  editor: {
    toggleGallery() {
      const isGalleryActive = templateGallery();
      if (config.runtime.editorMode !== isGalleryActive) {
        config.runtime.editorMode = isGalleryActive;
        action.config.save();
      }
      if (!isGalleryActive && !init._hasLoaded) {
        init();
      }
    }
  },
  move: {
    forward: () => advance([0, 0, -100]), // forward
    backward: () => advance([0, 0, 100]), // back
    left: () => advance([100,0,0]), // left
    right: () => advance([-100,0,0]), // right
    up: () => advance([0, 100, 0]),
    down: () => advance([0, -100, 0]),
  },
  view: {
    save: () => {
      if (!$camera._pos|| !$assembly._pos) {
        throw new Error('Attempted to save view without camera and assembly properties. Failing.');
      }
      const cameraPosRot = [$camera._pos, $camera._rot];
      const assemblyPosRot = [$assembly._pos, $assembly._rot];
      storage.save({
        cameraPosRot,
        assemblyPosRot,
        config,
      });
      p('saving view. paste to bake: \'' + JSON.stringify({ cameraPosRot, assemblyPosRot }) +'\'');
    },
    load: () => {
      let cameraPosRot, assemblyPosRot;
      if (!config.persistView) { // Using bakedState; deprecate this.
          cameraPosRot = defaults.cameraPosRot;
          assemblyPosRot = defaults.assemblyPosRot;
      } else {
        let stored;
        if (!engine.isDevHost()) {
          console.warn('Non-dev host detected. action.view.load will use bakedState.')
          stored = {};
        } else {
          stored = storage.load() || {};
        }
        const baked = JSON.parse(config.bakedState) || {};
        cameraPosRot = stored.cameraPosRot || baked.cameraPosRot || defaults.cameraPosRot;
        assemblyPosRot = stored.assemblyPosRot || baked.assemblyPosRot || defaults.assemblyPosRot;
      }
      move($camera, ...cameraPosRot, true);
      move($assembly, ...assemblyPosRot, true);

      p('loading view');
      return true;
    },
  },
  config: {
    save: () => {
      storage.save({ config }, true);
      console.log('merged config.');
    },
    toggleMouse: () => { config.mouseLook = !config.mouseLook },
  },
};

const mouse = {
  _pressed: {},
};
const keyboard = {
  bindings: {
    held: {
      KeyW: action.move.forward,
      KeyS: action.move.backward,
      KeyA: action.move.left,
      KeyD: action.move.right,
      KeyO: action.move.forward,
      KeyL: action.move.backward,
      KeyK: action.move.left,
      Semicolon: action.move.right,
      Space: action.move.up,
      ShiftRight: action.move.down,
      ShiftLeft: action.move.down,
    },
    normal: {
      KeyM: action.config.toggleMouse,
      KeyP: action.view.save,
      KeyI: action.view.load,
      Backslash: action.editor.toggleGallery,
    }
  },
  run() {
    if (this.hasModifier()) return; // for now
    for (let key in this._pressed) {
      this._pressed[key] && this.bindings.held[key] && this.bindings.held[key]();
    }
  },
  hasModifier() {
    for (let key in this._pressed) {
      if (this._pressed[key] === false) continue;
      if (['Meta', 'Alt', 'Control'].some(modifier => key.includes(modifier))) {
        return true;
      };
    }
  },
  _pressed: {},
};

const loadPrefabMap = (_texture) => ({
  // merely copy the template, without a container
  simple(templateClass, pos, rot, scale, url, $root = $assembly) {
    const $template = $('#templates ' + templateClass);
    if (!$template) throw new Error(`No template found for class "${templateClass}".`)
    // Don't really like this, but currently using it for the moon
    // Note: mutating the original template on purpose, so we can see it in the gallery.
    // Er... it won't run the perlin noise generator when starting from the gallery, though
    if (url) {
      $template.querySelector('.texture').style.backgroundImage = `url(${url})`;
    }
    const $templateClone = $template.cloneNode(true);
    move($templateClone, pos, rot, false, scale);
    $root.appendChild($templateClone);

    return $templateClone;
  },
  // This is a bit like simple, but rotates the rot separately from pos
  // move() should accomodate this behavior, but doesn't yet.
  // Another detail is that it will shift the parent's top/left style
  // so that the sprite is always visually centered on its position.
  sprite(templateClass, pos, rot, scale, $root = $assembly) {
    const $template = $('#templates ' + templateClass)
    let { width, height }= window.getComputedStyle($template);
    [width, height] = [width, height].map(n => parseInt(n));

    const $templateClone = $template.cloneNode(true);


    const $container = div('sprite-container.prefab',{
      top: -height/2 + 'px',
      left: -height/2 + 'px',
    });
    const $gimbal = div('sprite-gimbal', { width, height });
    $gimbal.appendChild($templateClone);
    $container.appendChild($gimbal);
    $root.appendChild($container);

    move($templateClone, null, rot);
    move($container, pos, null, false, scale);
    return $templateClone;
  },
  async signage(
    templateClass, pos, rot, drawMask, $root = $assembly, // these are the main params
    depth, sideColor, // these properties should be set via --depth and --side-color CSS vars
    baked = _texture,
  ) {
    const defaultDrawMask = [1,1,0,0,1,1]
    drawMask = drawMask ? drawMask.concat(defaultDrawMask.slice(drawMask.length)) : defaultDrawMask;
    const $container = div('.signage-container.prefab');
    let $template = $('#templates ' + templateClass);

    const computedStyle = window.getComputedStyle($template);
    let { width, height } = computedStyle;
    const computedSideColor = computedStyle.getPropertyValue('--side-color').trim(); // bleh
    const computedDepth = computedStyle.getPropertyValue('--depth').trim();

    sideColor = sideColor || computedSideColor;
    depth = depth || computedDepth;
    if (!sideColor || !depth) {
      throw new Error(`"Signage prefab for "${templateClass}" is missing sideColor or depth.`);
    }

    [width, height] = [width, height].map(n => parseInt(n));

    let tex = baked[templateClass];
    if (tex) {
      tex = await tex;
      const classList = '.'+[...$template.classList].join('.');
      $template = div(classList, styleFromTex(tex));
      [width, height] = [tex.width, tex.height];
      $template.style.opacity = 1;
    }

    const $front = $template.cloneNode(true);
    const $back =  $template.cloneNode(true);

    const $top = div('.signage-cap', {
      height: depth + 'px',
      width: width + 'px',
      background: hexShift(sideColor, 1),
    });
    const $bottom = $top.cloneNode();
    $bottom.style.background = hexShift(sideColor, -1);

    const $right = div('.signage-side', {
      height: height + 'px',
      width: depth + 'px',
      background: sideColor,
    });
    const $left = $right.cloneNode();

    move($front, [0,0,depth/2], [0,0,0]);
    move($back, [0,0,depth/2], [0,180,0]);
    move($top, [0,0,depth/2], [90,0,0]);
    move($bottom, [0,0,height-depth/2], [-90,0,0]);
    move($right, [0,0,depth/2], [0,-90,0]);
    move($left, [0,0,width-depth/2], [0,90,0]);

    // drawMask is in order of likeliness to need changing
    const $faces = [$left, $right, $back, $bottom, $top, $front]
      .filter((n, i) => drawMask[i])
      .forEach($face => $container.appendChild($face));
    move($container, pos, rot);
    $root.appendChild($container);
  },
  skybox(url, size = 1000, scale = 100, $root = $assembly) {
    const halfSize = scale*size/2;

    const $container = div('.skybox.prefab');
    const scales = Array(3).fill(scale);
    const toCubeMoveParams = ([rx, ry]) => ([[0, 0, -halfSize], [rx, ry, 0], false, scales]);
    const sides = [[0,-90],[0,0],[0,180],[0,90]];
    const caps = [[-90,0], [90,0]];

    const $faces = [...sides, ...caps]
      .map(toCubeMoveParams)
      .map(moveParams =>
        move(
          div('.skybox-face', {
            height: size,
            width: size,
            backgroundImage: `url(${url})`,
            backgroundSize: 'cover',
            backfaceVisibility: 'hidden',
          }),
          ...moveParams,
        ),
      );
    move($container, [0,0,0], [0,0,0]); // initialize, but houldn't have to.
    $container.append(...$faces);
    $root.appendChild($container);
  },
  async facade(signSelector, facadeSelector, pos, rot, scale, $root = $assembly, baked = _texture) {
    const $container = div('.conbini-container.prefab');
    const $signClone = $('#templates ' + signSelector).cloneNode(true);
    const $facadeClone = $('#templates ' + facadeSelector).cloneNode(true);

    move($facadeClone, [0,125,0], [0,0,0])


    $container.append(
      $signClone,
      $facadeClone,
    )

    $root.appendChild($container);
    move($container, pos, rot, false, [0.65,0.65,0.65]);
  },
  async building(
    storyCount, windowCount, pos, rot, scale,
    drawMask, windowTemplate = '.window', $root = $assembly, baked = _texture,
  ) {
    window._baked = baked;
    const defaultDrawMask = [1,1,0,1,1]; // no bottom; last is roof.
    drawMask = drawMask ? drawMask.concat(defaultDrawMask.slice(drawMask.length)) : defaultDrawMask;
    const dRoof = drawMask.pop();

    const $container = div('.building-container.prefab'); // make sure to get the height and nudge it up.
    let windowTex = baked[windowTemplate];

    // Hmm, not entirely happy with this. It's a placeholder for some
    // less-adhoc way to do parameterized bakes.
    const storyTexClass = `.bake-story-${windowTemplate.substr(1)}-${windowCount}`;
    //- console.log(storyTexClass);
    let storyTex = baked[storyTexClass];
    if (windowTex) windowTex = await windowTex;
    if (storyTex) storyTex = await storyTex;
    //- const $faces = [$left, $right, $back, $bottom, $top, $front]
    const $faces = [[0,0],[0,180],[0,-90],[0,90]] // left, right, back, front
    .filter((n, i) => drawMask[i])
    .map(([rx, ry]) => {
      const $face = div('.building.surface',
        storyTex && styleFromTex(storyTex, {
          height: ({ height, offsets }) => height*storyCount + offsets.extendBottom,
        }),
      );
      if (!storyTex) {
        const $stories = Array(storyCount).fill().map(story => {
          const $story = div('.story',
            windowTex && styleFromTex(windowTex, {
              width: ({ width, offsets }) => width*windowCount - offsets.width + 'px',
              backfaceVisibility: 'visible',
            }),
          );
          if (!windowTex) {
            const $windowTemplate =$('#templates ' + windowTemplate);
            $story.append(
              ...Array(windowCount).fill().map(_ => $windowTemplate.cloneNode(true)),
            );
          }
          return $story;
        });
        $face.append(...$stories);
      }
      move($face, null, [rx, ry, 0]);
      return $face;
    });


    $container.append(...$faces);
    $root.appendChild($container);

    // Move it in second pass, so we can use getComputedStyle
    let width, height;
    $faces.forEach($face => {
      //- window.foo = window.getComputedStyle($face);
      width = width || parseInt(window.getComputedStyle($face).width);
      height = height || parseInt(window.getComputedStyle($face).height);
      move($face, [0, -height, width/2]);
    });

    // Add and adjust the roof
    if (dRoof) {
      const $roof = div('.building.surface', {
        width,
        height: width,
      });
      move($roof, [0, 0, height + width/2], [90, 0, 90])
      $container.appendChild($roof);
    }

    move($container, pos, rot, false, scale);
    return $container;
  },
  windingRepeater(pieceLength = 5000, angle = 10, pos, rot, insertionFn, arcLength = 4, $root = $assembly) {
    const $container = div('.winding-repeater.prefab');
    const shouldInvert = i => !(Math.floor(i/arcLength) % 2);
    Array(arcLength*3).fill()
      .map((_, i) => insertionFn(pieceLength, i, shouldInvert(i)))
      .forEach(($piece, i, a) => {
        if (i) {
          const angleSign = Math.sign(angle)*(shouldInvert(i) ? -1 : 1);
          a[i-1].appendChild($piece); // attach to previous piece
          move($piece, [pieceLength, 0, 0], [0, 0, angleSign*angle]);
          return;
        }
        $container.appendChild($piece);
        move($piece, [pieceLength,0,0], [90, 0, 0]);
      });

    $root.appendChild($container);
    move($container, pos, rot);// [-8000,0,900], [0, 180, 0]);
  },
});

// Complexes are builder-functions for procedurally generating amalgamations of prefabs.
// We should probably rename "prefabs" to something like "primitives"
const loadComplex = (_prefab) => ({
  cityChunk(len, i, shouldInvert) {
    const $streetTemplate = $('#templates .street');
    const $streetClone = $streetTemplate.cloneNode(true);
    Object.assign($streetClone.style, {
      width: len + 'px',
      transformOrigin:  `100% ${shouldInvert ? '100%' : '0%'}`,
    })
    let { width, height } = window.getComputedStyle($streetTemplate);
    width = parseInt(width);
    height = parseInt(height);
    const roadWidth = height; // counterintuitive, so just to be clear; should probably fix
    //- storyCount, windowCount, pos, rot, scale,
    //- drawMask, windowTemplate = '.window', $root = $assembly,
    //- prefab.building

    // Remember, use seeded random
    const randomTemplate = _ => Math.random() < 0.5 ? '.window' : '.window-pane';
    const randomStoryCount = _ => Math.random()*6 + 3 | 0;

    // WARNING: the following assumes that the identifying template class is always first, by convention,
    // but there's no real way to throw an error if it isn't!
    const $shuffledSignage = shuffle($$('#templates .signage'));


    _prefab.building(
      randomStoryCount(), 4, [0, 0, roadWidth/2], [-90, 180, 0], null, [0,1], randomTemplate(), $streetClone,
    )
      .then($building => {
        let { width: bWidth, height: bHeight } = window.getComputedStyle($building.children[0]) // first face;
        bWidth = parseInt(bWidth);
        bHeight = parseInt(bHeight);

        const $signage = $shuffledSignage[0];
        const computedSignageStyle = window.getComputedStyle($signage);
        let { width: sWidth, height: sHeight } = computedSignageStyle;
        // WARNING: the following deprecates "depth" as prefab param unless I set the property manually!
        const sDepth = +computedSignageStyle.getPropertyValue('--depth');
        sWidth = parseInt(sWidth);
        sHeight = parseInt(sHeight);

        const maxHeightOffset = bHeight - sHeight;
        const maxWidthOffset = bWidth - sDepth;

        const randomHeightOffset = maxHeightOffset*Math.random();
        const randomWidthOffset = maxWidthOffset*Math.random();

        const signageSelector = '.'+$signage.classList[0];
        _prefab.signage(signageSelector, [bWidth/2,-sHeight-randomHeightOffset,sDepth/2+randomWidthOffset], [0,90,0], [1,0], $building);



        move($building, [0, 0, bWidth/2]);
      });
    _prefab.building(
      randomStoryCount(), 4, [0, 0, -roadWidth/2], [-90, 180, 0], null, [1,0], randomTemplate(), $streetClone,
    ).then($building => { // we need to wait for it to be inserted to get its computed properties
      let { width: bWidth, height: bHeight } = window.getComputedStyle($building.children[0]);
      bWidth = parseInt(bWidth);
      bHeight = parseInt(bHeight);

      // Add signage
      const $signage = $shuffledSignage[1];
      const computedSignageStyle = window.getComputedStyle($signage);
      let { width: sWidth, height: sHeight } = computedSignageStyle;
      // WARNING: the following deprecates "depth" as prefab param unless I set the property manually!
      const sDepth = +computedSignageStyle.getPropertyValue('--depth');
      sWidth = parseInt(sWidth);
      sHeight = parseInt(sHeight);

      const maxHeightOffset = bHeight - sHeight;
      const maxWidthOffset = bWidth - sDepth;

      const randomHeightOffset = maxHeightOffset*Math.random();
      const randomWidthOffset = maxWidthOffset*Math.random();

      const signageSelector = '.'+$signage.classList[0];
      _prefab.signage(signageSelector, [-bWidth/2-sWidth,-sHeight-randomHeightOffset,sDepth/2+randomWidthOffset], [0,90,0], [1,0], $building);

      move($building, [0, 0, -bWidth/2]);
    });
    return $streetClone; // return synchronously, because used in a parametric prefab
  },
});

// Handle any early business here:
document.addEventListener('keydown', ({ code }) => {
  keyboard._pressed[code] = true;
  !keyboard.hasModifier() && keyboard.bindings.normal[code] && keyboard.bindings.normal[code]();
});
document.addEventListener('keyup', ({ code }) => {
  console.log('RELEASED', code);
  keyboard._pressed[code] = false;
});

document.addEventListener('mousedown', (e) => {
  const code = [null,'MouseLeft', 'MouseMiddle','MouseRight'][e.which];
  //- console.log('PRESSED', code);
  if (code === 'MouseRight') e.preventDefault();
  mouse._pressed[code] = true;
})
document.addEventListener('mouseup', (e) => {
  const code = [null,'MouseLeft', 'MouseMiddle','MouseRight'][e.which];
  //- console.log('RELEASED', code);
  mouse._pressed[code] = false;
})

loadPersisted();

function loadPersisted() {
  // Maybe some of this should go elsewhere.
  const saved = storage.load();
  if (!saved) {
    init();
    return;
  }
  Object.assign(config.runtime, saved.config.runtime);
  if (config.runtime.editorMode) {
    action.editor.toggleGallery();
  } else {
    init();
  }
}


function init() {
  engine.perspective = 1200;

  const textureMap = bakeAll([
    ['.bake-story-window-4', { extendBottom: 50, scale: 0.4 }], // bleh, not a fan
    ['.bake-story-window-pane-4', { extendBottom: 50, scale: 0.4 }],
    ['.window', { width: -25, scale: 0.4 }],
    ['.window-pane', { width: -25, scale: 0.4 }],
    ['.yosh', { scale: 0.3}],
    ['.matsuya', { scale: 0.5 }],
    '.manga-kissa',
    ['.book-off', { scale: 0.5 }],
  ]);


  window.tex = textureMap;
  const prefab = loadPrefabMap(textureMap);
  const complex = loadComplex(prefab);

  prefab.windingRepeater(4800, -15, [-20000,0,6500], [0, 180-15*3, 0], (len, i, shouldInvert) => {

    return complex.cityChunk(len, i, shouldInvert);
    /*
      For now, this function will be used to inject "complexes",
      ie. procedurally generated prefabs, into each winding section.
      Practically speaking, this means an entire city-segment: a road piece, buildings, signage.

      It might be a good idea to use the seeded random function to easily make the
      pieces repeat in a controlled fashion (in this case, segments 10-12 should be
      identical to segments 1-3).
    */
  });

  prefab.skybox(generateStarImage(900, 0.005));
  prefab.sprite('.lantern-red', [1200, 250, -300], [0, 0, 0]);
  prefab.sprite('.ball-light', [1500, 350, -300], [0, 0, 0]);
  prefab.simple('.densha', [200,0,-1200], [0,90,0]);
  prefab.simple('.moon-container', [-1100,-11000,-51000], [0,56,0], [30,30,30], pilferedPerlinDump());
  //- prefab.simple('.moon-container', [-1100,-11000,-44000], [0,90,0], [30,30,30], pilferedPerlinDump());
  prefab.simple('.megaman', [300,-5450, -150], [0,-90,0]);

  prefab.signage('.red-karaoke', [90, -300, 800], [0, 90, 0], [1,0]);
  prefab.signage('.book-off', [90, -100, 350], [0, 90, 0], [1,0]);

  prefab.signage('.matsuya', [90, -600, 350], [0, 90, 0], [1,0]);

  prefab.signage('.manga-kissa', [690, -200, 800], [0, 90, 0], [0,1]);
  prefab.signage('.yosh',[690, -900, 350], [0, 90, 0], [0,1]);

  // Hmm, should probably re-param these, maybe by putting pos/rot/scale in same parameter
  prefab.building(20, 4, [0, 900, 450], null, null, [1,1]);
  //- prefab.building(6, 4, [0, 900, -1350], null, null, [1,0], '.window-pane');

  //- prefab.building(4, 4, [1800, 900, 450], null, null, [1,1]);
  //- prefab.building(4, 4, [1800, 900, -1350], null, null, [1,0]);

  prefab.facade('.famima-flat', '.conbini', [470, 490,-880], [0, 0, 0]);
  prefab.facade('.lawson-flat', '.conbini', [-690, 490,20], [0, 180, 0]);

  //- prefab.simple('.ddstar-container', [0,0,50000], [0,0,0], [100,100,100]);
  //- $('.star-container').style.backgroundImage = `url(${generateStarImage(1000, 0.01)})`
  //- move($('.floor'), [-6000,-450,-450], [90, 0, 0]);

  action.view.load();

  document.addEventListener('mousemove', e => {
    const { movementX, movementY } = e;

    //- diagnostics.update(e);
    engine.shouldUpdate() && (movementX !== 0 || movementY !== 0) &&
      (config.mouseLook || mouse._pressed.MouseMiddle) &&
        move($camera, null, [-movementY, movementX, 0]);
  });
  window.addEventListener('blur', e => {
    console.log('blurred, so saving view');
    action.view.save();
  });

  engine.update(keyboard);
  init._hasLoaded = true;
}


function move($el, pos, rot, absolute = false, scale) {
  if (!$el) throw new Error('$el cannot be null. Maybe you changed a class name?');
  if (absolute || !$el._pos || !$el._rot) {
    $el._pos = pos = pos || $el._pos || [0,0,0]; // assign to best non-null value
    $el._rot = rot = rot || $el._rot || [0,0,0];
  } else {
    $el._pos = pos = $el._pos.map((n, i) => (n + (pos ? pos[i] : 0)));
    $el._rot = rot = $el._rot.map((n, i) => (n + (rot ? rot[i] : 0))%360 );
    $el._rot[0] = min(max(-90, $el._rot[0]), 90);
  }
  scaleText = scale ? `scaleX(${scale[0]}) scaleY(${scale[1]}) scaleZ(${scale[2]})` : '';
  $el.style.webkitTransform =
    `rotateX(${rot[0]}deg) rotateY(${rot[1]}deg) rotateZ(${rot[2]}deg) translate3d(${pos[0]}px, ${pos[1]}px, ${pos[2]}px) skewX(0deg) skewY(0deg)` + scaleText;
  return $el;
}
function advance(velocity, _$camera = $camera, _$assembly = $assembly) {
  const [x, y, z] = velocity;
  const camY = _$camera._rot[1];
  const aX = cos(rad(camY))*x + sin(rad(camY))*z;
  const aZ = sin(rad(camY))*x - cos(rad(camY))*z;
  move(_$assembly, [aX, y, aZ]);
}

function stamp($node, $newParent, posRot) {
  const { _pos, _rot } = $node;
  const $clone = Object.assign($node.cloneNode(true), {_pos, _rot });
  $newParent.appendChild($clone);
  move($node, ...posRot);
  return $clone;
}

function stamps($node, $newParent, posRots) {
  return posRots.map(posRot => stamp($node, $newParent, posRot));
}

function hexShift(hex, shift) {
  return '#' + hex.substr(1).split('')
    .map(n => parseInt(n, 16))
    .map(n => Math.min(Math.max(n + shift,0),15))
    .map(n => n.toString(16))
    .join('');
}

function generateStarImage(size = 32, threshold = 0.004) {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  var context = canvas.getContext('2d');
  var imageDataObject = context.createImageData(size, size);
  var imageData = imageDataObject.data;
  for (let i = 0; i < size * size * 4; i += 4) {
    if (Math.random() > threshold) {
      imageData[i] = 0;
      imageData[i+1] = 0;
      imageData[i+2] = 0;
      imageData[i+3] = 255;
    } else {
      const r = Math.random()
      imageData[i] = r*255;
      imageData[i+1] = r*255;
      imageData[i+2] = r*255;
      imageData[i+3] = 255;
    }
  }
  context.putImageData(imageDataObject, 0, 0);
  return canvas.toDataURL();
}


function pilferedPerlinDump(size = 500) {
  let seed = 1;
  function seededRandom() {
    var x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  }

  const sand = {
    noiseColor: [255, 255, 255, 255],
    baseColor: [150, 150, 150, 255],
  };

  var grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1],
  [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];

  var p = [];
  for (var i = 0; i < 256; i++) {
    p[i] = Math.floor(seededRandom() * 256);
  }

  var perm = [];
  for (let i = 0; i < 512; i++) {
    perm[i] = p[i & 255];
  }


  return generateTexture(size, sand); // returns dataURL

  function generateTexture(size, data) {
    // create canvas and get its image data (access its pixels directly)
    const canvas = document.createElement('canvas');
    //- const canvas = $(selector);
    canvas.width = canvas.height = size;
    var context = canvas.getContext('2d');
    var imageDataObject = context.createImageData(size, size);
    var imageData = imageDataObject.data;

    // fill with base color
    for (var i = 0; i < size * size * 4; i += 4) {
      imageData[i] = data.baseColor[0];
      imageData[i + 1] = data.baseColor[1];
      imageData[i + 2] = data.baseColor[2];
      imageData[i + 3] = data.baseColor[3];
    }

    // add noise
    var n = new NoiseGenerator();
    var p = 0;
    for (var y = 0; y < size; y++) {
      for (var x = 0; x < size; x++) {
        // generate noise at current x and y coordinates (z is set to 0)
        var v = Math.abs(n.noise(x / size, y / size, 0));
        for (var c = 0; c < 3; c++, p++) {
          // use noiseColor's alpha channel to blend with base color
          imageData[p] = Math.floor(imageData[p] + v * data.noiseColor[c] *  data.noiseColor[3] / 255);
        }
        p++;
      }
    }
    context.putImageData(imageDataObject, 0, 0);
    return canvas.toDataURL();
  };


  function perlinDot(g, x, y, z) {
    return g[0] * x + g[1] * y + g[2] * z;
  }

  function NoiseGenerator(numOctaves = 4, attenuation = 2, roughness = 4, startingOctave = 0) {
    this.noise = (x, y, z) => {
      let a = Math.pow(attenuation, -startingOctave);
      let f = Math.pow(roughness, startingOctave);
      let m = 0;
      for (let i = startingOctave; i < numOctaves + startingOctave; i++) {
        m += n(x*f, y*f, z*f)*a;
        a /= attenuation;
        f *= roughness;
      }

      return m / numOctaves;
    }
  }

  function n(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x);
    var Y = Math.floor(y);
    var Z = Math.floor(z);

    // Get relative xyz coordinates of point within that cell
    x = x - X;
    y = y - Y;
    z = z - Z;

    // Wrap the integer cells at 255
    X &= 255;
    Y &= 255;
    Z &= 255;

    // Calculate a set of eight hashed gradient indices
    var gi000 = perm[X + perm[Y + perm[Z]]] % 12;
    var gi001 = perm[X + perm[Y + perm[Z + 1]]] % 12;
    var gi010 = perm[X + perm[Y + 1 + perm[Z]]] % 12;
    var gi011 = perm[X + perm[Y + 1 + perm[Z + 1]]] % 12;
    var gi100 = perm[X + 1 + perm[Y + perm[Z]]] % 12;
    var gi101 = perm[X + 1 + perm[Y + perm[Z + 1]]] % 12;
    var gi110 = perm[X + 1 + perm[Y + 1 + perm[Z]]] % 12;
    var gi111 = perm[X + 1 + perm[Y + 1 + perm[Z + 1]]] % 12;

    // Calculate noise contributions from each of the eight corners
    var n000 = perlinDot(grad3[gi000], x, y, z);
    var n100 = perlinDot(grad3[gi100], x - 1, y, z);
    var n010 = perlinDot(grad3[gi010], x, y - 1, z);
    var n110 = perlinDot(grad3[gi110], x - 1, y - 1, z);
    var n001 = perlinDot(grad3[gi001], x, y, z - 1);
    var n101 = perlinDot(grad3[gi101], x - 1, y, z - 1);
    var n011 = perlinDot(grad3[gi011], x, y - 1, z - 1);
    var n111 = perlinDot(grad3[gi111], x - 1, y - 1, z - 1);

    // Compute the ease curve value for each of x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate (along x) the contributions from each of the corners
    var nx00 = mix(n000, n100, u);
    var nx01 = mix(n001, n101, u);
    var nx10 = mix(n010, n110, u);
    var nx11 = mix(n011, n111, u);

    // Interpolate the four results along y
    var nxy0 = mix(nx00, nx10, v);
    var nxy1 = mix(nx01, nx11, v);

    // Interpolate the last two results along z
    return mix(nxy0, nxy1, w);
  }

  function mix(a, b, t) {
    return (1 - t) * a + t * b;
  }

  function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }
}

// Simple wrapper to pluck the first node in #templates and texturize it
// Currently, only bakeAll is used, but keeping this just in case, for now
function bake(selector, offsets) {
  return nodeToTexture(...prepareBakeInfo(selector, offsets));
}

// Finds the template, prepares any CSS if necessary, returns nodeToTexture params
function prepareBakeInfo(selector, offsets, _$ = $) {
  if (window._elapsed === undefined) window._elapsed = 0;
  const $template = $('#templates ' + selector);
  let $styles;
  if (!$template.querySelector('style')) {
    console.warn(`BAKE: no style tag found in '#template ${selector}'. Will generate it manually, which is slower.`);
    $styles = generateTemplateStyles($template, ['#texture *']);
  }
  return [$template, offsets, $styles];
}

function bakeAll(selectors, _config = config, _db = db, _action = action) {
  let updateCount = 0;
  const texturePromises = []; // Resolve in order to trigger action.config.save(), if needed

  const entries = selectors.map((selector, i) => {
    let offsets;
    [selector, offsets] = Array.isArray(selector) ? selector : [selector];
    const [$template, , $styles] = prepareBakeInfo(selector, offsets);
    // Handle the bakedHashmap stuff here. Include offsets in the hash for now.
    const contentHash = hash($template.outerHTML + $styles.outerHTML + JSON.stringify(offsets));
    const { bakedHashMap } = _config.runtime;
    // Check IndexedDB first; it'll return null if it doesn't exist.
    const texturePromise = _db.getBlobAsUrl(selector).then(maybeUrl => {
      if (maybeUrl && bakedHashMap[selector] && bakedHashMap[selector].contentHash === contentHash) {
        console.warn('Congratulations; loading from IndexedDB');
        const { height, width } = bakedHashMap[selector];
        offsets = Object.assign({ width: 0, height: 0, scale: 1, extendBottom: 0, extendTop: 0 }, offsets);
        return { url: maybeUrl, height, width, offsets }; // Skip nodeToTexture; use its format
      } else {
        console.error("Couldn't load texture from IndexedDB for some reason");
        // Hash has changed, so unconditionally process and write the new version.
        // Run nodeToTexture, and peek inside in order to save the blob.
        // On last update, run _action.config.save().
        const texturePromiseWithUpdate = nodeToTexture($template, offsets, $styles)
          .then(texture => {
            const { url, height, width } = texture;
            bakedHashMap[selector] = { contentHash, height, width }; // don't save offsets
            _db.putBlobFromUrl(selector, url);
            updateCount++;
            return texture;
          });
        return texturePromiseWithUpdate;
      }
    });
    texturePromises.push(texturePromise);
    return [selector, texturePromise];
  });
  Promise.all(texturePromises)
    .then(_ => {
      if (updateCount) {
        _action.config.save();
        console.error(`Saved ${updateCount} new textures to IndexedDB.`);
      }
    });
  return Object.fromEntries(entries);
}

// Simple function to make an object of promises synchronous
function sync(obj, dec) {
  const { assign, values, fromEntries, keys } = Object;
  return Promise.all(values(obj))
    .then(v =>
      fromEntries(keys(obj).map((k, i) => ([k, v[i]])),
    ),
  );
}

function nodeToTexture($template, offsets, $styles, containerId = 'texture') {
  offsets = Object.assign({ width: 0, height: 0, scale: 1, }, offsets);
  if (!$template) throw new Error(`nodeToTexture requires a valid DOM node.`);
  let {
    width,
    height,
    marginLeft: marginWidth,
    marginTop: marginHeight,
  } = window.getComputedStyle($template);
  if (!width || !height) throw new Error("Couldn't find template width and/or height.");

  marginWidth = parseInt(marginWidth);
  marginHeight = parseInt(marginHeight);
  width = parseInt(width) + 2*marginWidth + offsets.width;
  height = parseInt(height) + 2*marginHeight + offsets.height;

  const svg = _makeSvg($template, width, height, marginWidth, marginHeight, offsets, $styles);
  return _svgToImage(svg, width, height, offsets);

  function _svgToImage(svg, width, height, offsets) {
    let resolve, reject;
    let readyPromise = new Promise((r, j) => [resolve, reject] = [r, j]);

    const canvas = document.createElement('canvas');
    canvas.width = width*offsets.scale;
    canvas.height = height*offsets.scale;
    const ctx = canvas.getContext('2d');

    const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
    const img = new Image();
    const reader = new FileReader();
    reader.onerror = _ => reject(new Error('Reader loading failed in nodeToTexture.'));
    img.onerror = _ => reject(new Error('Img loading failed in nodeToTexture.'));

    reader.onload = e => img.src = e.target.result;
    img.onload = _ => {
      ctx.drawImage(img, 0, 0);
      canvas.toBlob(blob => {
        const url = window.URL.createObjectURL(blob);
        resolve({ url, height, width, offsets });
      });
    }
    reader.readAsDataURL(blob); // trigger the load events
    return readyPromise;
  }

  function _makeSvg($node, width, height, marginWidth, marginHeight, { scale }, $styles) {
    //- const { protocol } = window.location; // no, doesn't work
    if (scale !== 1) {
      $node = $node.cloneNode(true); // Clone it, since we need to modify it
      Object.assign($node.style, {
        transform: `scale(${scale})`,
        transformOrigin: '0% 0%',
        margin: `${marginHeight*scale}px ${marginWidth*scale}px`,
      });
    }
    const stylesHTML = $styles ? $styles.outerHTML : '';
    //- console.log('??', scale, width);
    return `
      <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
        <foreignObject width="100%" height="100%">
          ${stylesHTML}
          <div id="${containerId}" xmlns="${document.documentElement.namespaceURI}">
            ${$node.outerHTML}
          </div>
        </foreignObject>
      </svg>
    `;
  }
}

//wat = generateTemplateStyles($('#templates .yosh'));
function generateTemplateStyles(
  $template,
  globals = [],
  $sourceStyle = document.querySelector('style'),
) {
  const classes = _getClasses($template);
  const classesAndGlobals = [...globals, ...classes];
  const rules = $sourceStyle.sheet.cssRules;
  const filteredRules = [];
  for (let i in rules) {
    const rule = rules[i];
    const { selectorText } = rule;
    if (selectorText && classesAndGlobals.some(c => selectorText.indexOf(c) !== -1)) {
      filteredRules.push(rule.cssText);
    }
  }
  const $styles = document.createElement('style');
  $styles.appendChild(document.createTextNode(
    filteredRules.join('\n'),
  ));

  return $styles;
  //const foo = getClasses($('#templates .yosh'));
  function _getClasses($root) {
    const iterator = document.createNodeIterator($root, NodeFilter.SHOW_ELEMENT);
    let node;
    let classMap = {};
    while (node = iterator.nextNode()) {
      node.classList.forEach(n => classMap[n] = true);
    }
    return Object.keys(classMap);
  }
}
function styleFromTex(tex, custom = {}) {
    const scale = tex.offsets.scale || 1;
    const result = {
      height: tex.height + 'px',
      width: tex.width + 'px',
      backgroundImage: `url(${tex.url})`,
      backgroundSize: `${tex.width}px ${tex.height}px`,
      border: 'none',
    };
    for (let key in custom) {
      const fn = custom[key];
      result[key] = (typeof fn === 'function') ? fn(tex) : fn;
    }
    return result;
}

// sigh, wanted this before, so just including it
function trimdent(text) {
  const mindent = text
    .replace(/[^\s]/g,'')
    .split('\n')
    .map(n => n.length)
    .filter((n, i, a) => n && i && i < a.length - 1)
    .sort((a, b) => a-b)[0] - 1;
  return text.replace(RegExp(` {${mindent}}`, 'g'), '');
}

function calculateLookAtMatrix(entity, target, up) {  // this was adapted from three.js
    const te = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1,
    ];
    const z = normalize(subVectors(entity, target));

    if (lengthSq(z) === 0) z[2] = 1;

    let x = normalize(crossVectors(up, z)); // get vector perpendicular to up and z
    if (lengthSq(x) === 0 ) {
        z[2] += 0.0001; // if z is zero vector, then, add a bit to z[2]
        x = normalize(crossVectors(up, z));
    }

    const y = crossVectors(z, x); // get vector perpendicular to z and x, set to y

    // set up the matrix
    te[0] = x[0]; te[4] = y[0]; te[8] = z[0];
    te[1] = x[1]; te[5] = y[1]; te[9] = z[1];
    te[2] = x[2]; te[6] = y[2]; te[10] = z[2];

    return te;

  function normalize(vec) {
      const m = Math.sqrt(vec.reduce((a, n) => a+n**2,0));
      return vec.map(n => n/m);
  }

  function subVectors(v1, v2) {
      return [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]];
  }

  function crossVectors(v1, v2) {
      return [v1[1]*v2[2]-v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1]-v1[1]*v2[0]];
  }

  function lengthSq(v) {
      return v.reduce((a, n) => a + n**2, 0);
  }
};

function setMatrix($el, matrix) {
    Object.assign($el.style, {
       transform: `matrix3d(${matrix.join(',')})`,
    });
}

//- templateGallery(['.megaman']);//['.megaman', '.moon-container']);
function templateGallery(hideList = [], _config = config, _action = action) {
  const $showcase = $('#template-editor .flex-container');
  const $bigFirst = $('#template-editor .big-first');
  const $editor = $('#template-editor');
  const turnEditorOn = $editor.classList.contains('hidden');
  const addOrRemove = turnEditorOn ? 'remove' : 'add';
  $editor.classList[addOrRemove]('hidden');
  if (templateGallery._hasLoaded) return turnEditorOn;

  const $templates = $$('#templates > *');
  $templates.forEach(_addIcon($showcase, 275, 1, ($icon, $el, i) => {
    $icon.addEventListener('click', _ => _setBigIcon($el, i));
  }));
  _addIcon($bigFirst, 800, 2)($templates[_config.runtime.selectedTemplate] || $templates[0]);

  templateGallery._hasLoaded = true;
  return turnEditorOn;

  function _setBigIcon($el, i) {
    $bigFirst.removeChild($bigFirst.firstChild);
    _addIcon($bigFirst, 800, 2)($el);
    config.runtime.selectedTemplate = i;
    _action.config.save();
    //- $editor.scrollTo({ top: 0, behavior: 'smooth' })
  }

  function _addIcon($parent, iconSize, maxScale = 1, cb) {
    return ($el, i) => {
      //- console.log(hideList.some(n => $el.classList.contains(n)));
      if (hideList.some(n => $el.classList.contains(n.substr(1)))) return;
      let { width, height } = window.getComputedStyle($el);
      width = parseInt(width);
      height = parseInt(height);
      bigger = width > height ? width : height;

      const $icon = div('.editor-icon', {
        width: iconSize,
        height: iconSize,
      });

      //- const iconSize = 400;
      const scale = Math.min((iconSize - 60)/bigger, maxScale);
      const $clone = $el.cloneNode(true);
      Object.assign($clone.style, {
        margin: '-5px', // Negative of border
        boxSizing: 'border-box',
        left: (iconSize-width*scale)/2,
        top: (iconSize-height*scale)/2,
        transform: `scale(${scale})`,
      });

      cb && cb($icon, $el, i);
      $icon.appendChild($clone);
      $parent.appendChild($icon);
    };
  }
}

function getFullSelector($el) {
  var selector = '';
  const sClasses = [].slice.apply($el.classList).join('.');
  const sId = $el.id;
  if (sClasses) selector += '.' + sClasses;
  if (sId) selector += '#' + sId;
  return selector;
}

function hash(string) {
  const start = Date.now()
  var hash = 0, i, chr;
  if (string.length === 0) return hash;
  for (i = 0; i < string.length; i++) {
    hash  = ((hash << 5) - hash) + string.charCodeAt(i) | 0;
  }
  return hash;
};

$('#anim').oninput = makeTick({
 initial: [[-15557, -360, -5789], [-10, 315, 0]],
 frameCount: 100,
 roadCount: 9,
 roadLength: 4700,
 roadAngle: -15,
 transform: e => 500 - +e.target.value,
});

function makeTick({ initial: [pos, rot], frameCount, roadCount, roadLength, roadAngle, transform = n => n }) {
  const shouldInvert = i => !(Math.floor(i/4) % 2);
  return function tick(frame) {
    frame = transform(frame);
    const lastRot = $camera._rot;
    const lastPos = $assembly._pos;
    const mixRot = [lastRot[0], rot[1], rot[2]];
    const mixPos = [pos[0], lastPos[1], pos[2]];
    move($camera, undefined, mixRot, true);
    move($assembly, mixPos, undefined, true);

    const roadIndexFloat = frame/frameCount*roadCount%roadCount;
    const roadIndex = roadIndexFloat | 0;

    const percentInRoad = roadIndexFloat - roadIndex;


    Array(roadIndex+1).fill().forEach((n, i) => {
      const angleSign = shouldInvert(i+1) ? 1 : -1;
      //- console.log(i === roadIndex, percentInRoad);
      const percent = i === roadIndex ? percentInRoad : 1;
      advance([-225*angleSign*percent,0, -roadLength*percent]);
      move($camera, null, [0, roadAngle*angleSign*percent, 0]);
    });
  }
}

function getSeedableRandom(underSeed) {
  const _underSeed = underSeed || Math.random()*100;
  return seed => {
    var x = Math.sin(_underSeed+seed) * 10000;
    return x - Math.floor(x);
  }
}

function shuffle(array) {
  let m = array.length, t, i;
  while (m) {
    i = Math.floor(Math.random() * m--);
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}</script></body>